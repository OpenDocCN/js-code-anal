# WebGal源码解析 0

![WebGAL](https://user-images.githubusercontent.com/30483415/227242979-297ff392-f210-47ef-b0e9-d4788ddc8df0.png)

### **[English Version](/README_EN.md)** | **[日本語版](/README_JP.md)** | **[한국어](/README_KO.md)** | **[Français](/README_FR.md)**

**[Help us with translation | 协助翻译 | 翻訳のお手伝い | 번역을 도와주세요](https://github.com/MakinoharaShoko/WebGAL/tree/dev/packages/webgal/src/translations)**

**[Join Discord Server | 加入 Discord 讨论 | Discordのディスカッションに参加する](https://discord.gg/kPrQkJttJy)**

# WebGAL

**界面美观、功能强大、易于开发的全新网页端视觉小说引擎**

## 在线体验

#### WebGAL 示例游戏，一般会演示最新开发的功能

https://demo.openwebgal.com

#### 完整的游戏

[铃色☆记忆](http://hoshinasuzu.cn/) by 星奈组  [备用链接](http://hoshinasuzu.cc/)

[Elf of Era Idols Project](https://store.steampowered.com/app/2414730/Elf_of_Era_Idols_Project/) (通过 Steam 获取)

## 使用 WebGAL 制作游戏

[WebGAL 开发文档](https://docs.openwebgal.com/)

[下载 WebGAL 图形化编辑器](https://github.com/MakinoharaShoko/WebGAL_Terre/releases)

你也可以使用源代码或 [WebGAL 调试工具](https://github.com/MakinoharaShoko/WebGAL/releases) 制作游戏，并使用 [WebGAL Script VS Code 插件](https://marketplace.visualstudio.com/items?itemName=c6h5-no2.webgal-script-basics) 来启用语法高亮

## WebGAL 优势与特色

一次编写，处处运行，无需网页开发基础，3 分钟即可学会所有的语法，只要你有灵感，就可以立刻开始开始创作你自己的视觉小说！

### 界面美观

美观优雅的图形用户界面与交互效果，一切都是为了更好的用户体验。

### 功能强大

不仅支持主流视觉小说引擎所具有的几乎全部功能，你还可以使用 Pixi.js 为你的游戏添加自定义效果。

### 易于开发

无论是使用 WebGAL 脚本还是使用可视化编辑器进行开发，一切都是那么简单自然。

### 参与 WebGAL 的开发工作

**想要参与引擎开发的开发者请阅读 [此项目的参与指南](https://docs.openwebgal.com/developers/)**

### 赞助

WebGAL 是一款开源软件，因此你可以免费在 MPL-2.0 开源协议的范畴下使用本软件，并可用于商业使用。

但即便如此，你的赞助也可以给予开发者前进的动力，让这个项目变得更好。

[赞助本项目](https://docs.openwebgal.com/sponsor/)

# Sponsor

## Gold Sponsors

| <img src="https://avatars.githubusercontent.com/u/91712707?v=4" alt="T2"   width="150px" height="150px" /> | <img src="https://avatars.githubusercontent.com/u/36291011?v=4" alt="Alex Shan"   width="150px" height="150px" /> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [T2-official(T2)](https://github.com/T2-official)            | [Alex Shan](https://github.com/Shan-mx)            |

## Silver Sponsors
| <img src="https://avatars.githubusercontent.com/u/103700780?v=4" alt="IdrilK"  width="150px" height="150px" /> |
| ------------------------------------------------------------ |
| [IdrilK](https://github.com/IdrilK)            |

## Sponsors
| <img src="https://avatars.githubusercontent.com/u/71590526?v=4" alt="Yuji Sakai"  width="150px" height="150px" /> | <img src="https://avatars.githubusercontent.com/u/49630998?v=4" alt="Iara"  width="150px" height="150px" /> |
| ------------------------------------------------------------ |------------------------------------------------------------ |
| [Yuji Sakai (generalfreed)](https://github.com/generalfreed) |[Iara (labiker)](https://github.com/labiker) |

## Stargazers over time

[![Stargazers over time](https://starchart.cc/MakinoharaShoko/WebGAL.svg)](https://starchart.cc/MakinoharaShoko/WebGAL)


![WebGAL](https://user-images.githubusercontent.com/30483415/227242979-297ff392-f210-47ef-b0e9-d4788ddc8df0.png)

**[中文版本](/README.md)**

**[Help us with translation | 协助翻译 | 翻訳のお手伝い ](https://github.com/MakinoharaShoko/WebGAL/tree/dev/packages/webgal/src/translations)**

**[Join Discord Server](https://discord.gg/kPrQkJttJy)**

# WebGAL

**A visually appealing, feature-rich, and easy-to-develop new web-based visual novel engine**

Demo video: https://www.bilibili.com/video/BV1jS4y1i7Wz/

## Online Experience

A short example:

https://demo.openwebgal.com

A complete game:

[铃色☆记忆](http://hoshinasuzu.cn/) by Hoshinasuzu  [备用链接](http://hoshinasuzu.cc/)

### Creating Games with WebGAL

[WebGAL Development Documentation](https://docs.openwebgal.com/)

[Download WebGAL Graphical Editor](https://github.com/MakinoharaShoko/WebGAL_Terre/releases)

## WebGAL Advantages and Features

Write once, run everywhere, no web development background needed, learn all syntax in 3 minutes, start creating your own visual novel as soon as inspiration strikes!

### Visually Appealing Interface

Beautiful and elegant graphical user interface and interaction effects, all for a better user experience.

### Feature-Rich

Supports almost all features of mainstream visual novel engines, plus you can use Pixi.js to add custom effects to your game.

### Easy to Develop

Whether using WebGAL scripts or the visual editor for development, everything is simple and natural.

### Participate in WebGAL Development

**Developers who want to participate in engine development, please read [the participation guide for this project](https://docs.openwebgal.com/developers/)**

### Sponsorship

WebGAL is an open-source software, so you can use this software for free under the scope of the MPL-2.0 open-source license, and it is available for commercial use.

Even so, your sponsorship can provide motivation for the developers to move forward and make this project even better.

[Sponsor this project](https://docs.openwebgal.com/sponsor/)

# Sponsor

## Gold Sponsors

| <img src="https://avatars.githubusercontent.com/u/91712707?v=4" alt="T2"   width="150px" height="150px" /> | <img src="https://avatars.githubusercontent.com/u/36291011?v=4" alt="Alex Shan"   width="150px" height="150px" /> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [T2-official(T2)](https://github.com/T2-official)            | [Alex Shan](https://github.com/Shan-mx)            |

## Silver Sponsors
| <img src="https://avatars.githubusercontent.com/u/103700780?v=4" alt="IdrilK"  width="150px" height="150px" /> |
| ------------------------------------------------------------ |
| [IdrilK](https://github.com/IdrilK)            |

## Sponsors
| <img src="https://avatars.githubusercontent.com/u/71590526?v=4" alt="Yuji Sakai"  width="150px" height="150px" /> | <img src="https://avatars.githubusercontent.com/u/49630998?v=4" alt="Iara"  width="150px" height="150px" /> |
| ------------------------------------------------------------ |------------------------------------------------------------ |
| [Yuji Sakai (generalfreed)](https://github.com/generalfreed) |[Iara (labiker)](https://github.com/labiker) |

## Stargazers over time

[![Stargazers over time](https://starchart.cc/MakinoharaShoko/WebGAL.svg)](https://starchart.cc/MakinoharaShoko/WebGAL)


Voici la traduction du texte en français :

![WebGAL](https://user-images.githubusercontent.com/30483415/227242979-297ff392-f210-47ef-b0e9-d4788ddc8df0.png)

**[中文版本](/README.md)**
**[English](/README_EN.md)**

**[Aidez-nous avec la traduction | 协助翻译 | 翻訳のお手伝い](https://github.com/MakinoharaShoko/WebGAL/tree/dev/packages/webgal/src/translations)**

**[Rejoindre le serveur Discord](https://discord.gg/kPrQkJttJy)**

# WebGAL

**Un moteur de visual novel basé sur le web, attrayant visuellement, riche en fonctionnalités et facile à développer**

Vidéo de démonstration : https://www.bilibili.com/video/BV1jS4y1i7Wz/

## Expérience en ligne

Un exemple court :

https://demo.openwebgal.com

Un jeu complet :

[铃色☆记忆](http://hoshinasuzu.cn/) de Hoshinasuzu [Lien de secours](http://hoshinasuzu.cc/)

### Créer des jeux avec WebGAL

[Documentation de développement WebGAL](https://docs.openwebgal.com/)

[Télécharger l'éditeur graphique WebGAL](https://github.com/MakinoharaShoko/WebGAL_Terre/releases)

## Avantages et fonctionnalités de WebGAL

Écrivez une fois, exécutez partout, aucune expérience en développement web requise, apprenez toutes les syntaxes en 3 minutes, commencez à créer votre propre visual novel dès que l'inspiration vous frappe !

### Interface visuellement attrayante

Interface utilisateur graphique belle et élégante avec des effets d'interaction, le tout pour une meilleure expérience utilisateur.

### Riche en fonctionnalités

Prend en charge presque toutes les fonctionnalités des moteurs de visual novel populaires, et vous pouvez utiliser Pixi.js pour ajouter des effets personnalisés à votre jeu.

### Facile à développer

Que vous utilisiez les scripts WebGAL ou l'éditeur visuel pour le développement, tout est simple et naturel.

### Participer au développement de WebGAL

**Les développeurs souhaitant participer au développement du moteur, veuillez lire [le guide de participation pour ce projet](https://docs.openwebgal.com/developers/)**

### Soutenir

WebGAL est un logiciel open-source, vous pouvez donc utiliser ce logiciel gratuitement dans le cadre de la licence open-source MPL-2.0, et il est disponible pour une utilisation commerciale.

Cependant, votre soutien peut motiver les développeurs à avancer et à rendre ce projet encore meilleur.

[Soutenir ce projet](https://docs.openwebgal.com/sponsor/)

# Sponsors

## Sponsors Gold

| <img src="https://avatars.githubusercontent.com/u/91712707?v=4" alt="T2"   width="150px" height="150px" /> | <img src="https://avatars.githubusercontent.com/u/36291011?v=4" alt="Alex Shan"   width="150px" height="150px" /> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [T2-official(T2)](https://github.com/T2-official)            | [Alex Shan](https://github.com/Shan-mx)            |

## Silver Sponsors
| <img src="https://avatars.githubusercontent.com/u/103700780?v=4" alt="IdrilK"  width="150px" height="150px" /> |
| ------------------------------------------------------------ |
| [IdrilK](https://github.com/IdrilK)            |

## Sponsors
| <img src="https://avatars.githubusercontent.com/u/71590526?v=4" alt="Yuji Sakai"  width="150px" height="150px" /> | <img src="https://avatars.githubusercontent.com/u/49630998?v=4" alt="Iara"  width="150px" height="150px" /> |
| ------------------------------------------------------------ |------------------------------------------------------------ |
| [Yuji Sakai (generalfreed)](https://github.com/generalfreed) |[Iara (labiker)](https://github.com/labiker) |

## Pour les amateurs de Stargazers (Historique GitHub stars)

[![Stargazers au fil du temps](https://starchart.cc/MakinoharaShoko/WebGAL.svg)](https://starchart.cc/MakinoharaShoko/WebGAL)


![WebGAL](https://user-images.githubusercontent.com/30483415/227242979-297ff392-f210-47ef-b0e9-d4788ddc8df0.png)

**[中文版本](/README.md)**

**[Help us with translation | 协助翻译 | 翻訳のお手伝い ](https://github.com/MakinoharaShoko/WebGAL/tree/dev/packages/webgal/src/translations)**

**[Join Discord Server](https://discord.gg/kPrQkJttJy)**

# WebGALとは

**WebGALは、Webベースのビジュアルノベルエンジンです。魅力的な機能が豊富で、ビジュアルノベルゲームの開発が簡単にできます。**

デモビデオ: https://youtu.be/S7xxVe9MGXk

## ゲーム紹介

デモゲーム（一部AI画像を使用しています）:

https://webgal-jp-demo.onrender.com/

現在公開されているゲーム（中国語）:

[ベルカラー☆メモリー](http://hoshinasuzu.cn/suzu.html) by Hoshinasuzu  [代替リンク](http://hoshinasuzu.cc/)

### WebGALでゲームを作成

[WebGAL 開発ドキュメント](https://docs.openwebgal.com/)
※日本語の開発ドキュメントは準備中です

[WebGAL Webエディターのダウンロードはこちら](https://github.com/MakinoharaShoko/WebGAL_Terre/releases)

## WebGALの魅力と機能

WebGALは、プログラミング知識が不要で、簡単にビジュアルノベルゲームを作ることができます。
<br>作成したゲームをウェブサイトに公開すると、プレイヤーは、パソコンやスマホからいつでもどこでもゲームをプレイすることができます。
<br>ウェブサイトだけではなく、Windowsで実行できるファイルとして出力することも可能です。

主流のビジュアルノベルエンジンのほぼすべての機能をサポートしており、アニメーションや特殊効果を使用して、ゲームのエフェクトをカスタマイズすることも可能です。

### WebGALのエンジン開発に参加（オープンソースプロジェクトに参加）

**エンジン開発に参加したい開発者は、[このプロジェクトの参加ガイド](https://docs.openwebgal.com/developers/)をお読みください**
<br>上記のDiscordに参加すると多くの情報を得ることができます。

### スポンサーシップ

WebGAL はオープンソース ソフトウェアであるため、MPL-2.0 オープンソース ライセンスの範囲内で無料で使用でき、商用利用も可能です。
<br>スポンサーシップは、開発者が前進し、このプロジェクトをさらに改善する動機となることができます。

[このプロジェクトのスポンサー](https://docs.openwebgal.com/sponsor/)

# Sponsor

## Gold Sponsors

| <img src="https://avatars.githubusercontent.com/u/91712707?v=4" alt="T2"   width="150px" height="150px" /> | <img src="https://avatars.githubusercontent.com/u/36291011?v=4" alt="Alex Shan"   width="150px" height="150px" /> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [T2-official(T2)](https://github.com/T2-official)            | [Alex Shan](https://github.com/Shan-mx)            |

## Silver Sponsors
| <img src="https://avatars.githubusercontent.com/u/103700780?v=4" alt="IdrilK"  width="150px" height="150px" /> |
| ------------------------------------------------------------ |
| [IdrilK](https://github.com/IdrilK)            |

## Sponsors
| <img src="https://avatars.githubusercontent.com/u/71590526?v=4" alt="Yuji Sakai"  width="150px" height="150px" /> | <img src="https://avatars.githubusercontent.com/u/49630998?v=4" alt="Iara"  width="150px" height="150px" /> |
| ------------------------------------------------------------ |------------------------------------------------------------ |
| [Yuji Sakai (generalfreed)](https://github.com/generalfreed) |[Iara (labiker)](https://github.com/labiker) |

## Stargazers over time

[![Stargazers over time](https://starchart.cc/MakinoharaShoko/WebGAL.svg)](https://starchart.cc/MakinoharaShoko/WebGAL)


![WebGAL](https://user-images.githubusercontent.com/30483415/227242979-297ff392-f210-47ef-b0e9-d4788ddc8df0.png)

**[中文版本](/README.md)**

**[번역을 도와주세요 | 翻译协助 | 翻訳のお手伝い ](https://github.com/MakinoharaShoko/WebGAL/tree/dev/packages/webgal/src/translations)**

**[Discord 서버 참가하기](https://discord.gg/kPrQkJttJy)**

# WebGAL

**시각적으로 매력적이며, 기능이 풍부하고, 쉽게 개발할 수 있는 새로운 웹 기반 비주얼 노벨 엔진**

데모 비디오: https://www.bilibili.com/video/BV1jS4y1i7Wz/

## 온라인 체험

짧은 예시:

https://demo.openwebgal.com

완성된 게임:

[铃色☆记忆](http://hoshinasuzu.cn/) by Hoshinasuzu  [백업 링크](http://hoshinasuzu.cc/)

### WebGAL로 게임 만들기

[WebGAL 개발 문서](https://docs.openwebgal.com/)

[WebGAL 그래픽 에디터 다운로드](https://github.com/MakinoharaShoko/WebGAL_Terre/releases)

## WebGAL의 장점 및 특징

한 번 작성하면 어디서든 실행할 수 있으며, 웹 개발 배경이 필요 없으며, 모든 구문을 3분 만에 배울 수 있고, 영감이 떠오르자마자 자신만의 비주얼 노벨을 만들기 시작할 수 있습니다!

### 시각적으로 매력적인 인터페이스

아름답고 우아한 그래픽 사용자 인터페이스와 상호작용 효과, 모두가 더 나은 사용자 경험을 위한 것입니다.

### 특징이 풍부함

주요 비주얼 노벨 엔진의 거의 모든 기능을 지원하며, 게임에 사용자 정의 효과를 추가하기 위해 Pixi.js를 사용할 수 있습니다.

### 개발하기 쉬움

WebGAL 스크립트를 사용하든 비주얼 에디터를 사용하든 개발은 모두 간단하고 자연스럽습니다.

### WebGAL 개발에 참여하기

**엔진 개발에 참여하고 싶은 개발자는 [이 프로젝트에 참여하기 위한 안내서](https://docs.openwebgal.com/developers/)를 읽어주세요.**

### 후원

WebGAL은 오픈소스 소프트웨어이므로 MPL-2.0 오픈소스 라이센스의 범위 내에서 이 소프트웨어를 무료로 사용할 수 있으며, 상업적으로 사용할 수 있습니다.

그럼에도 불구하고, 귀하의 후원은 개발자들에게 동기를 부여하고 이 프로젝트를 더욱 발전시키는 데 도움이 될 수 있습니다.

[이 프로젝트 후원하기](https://docs.openwebgal.com/sponsor/)

# 후원자

## Gold Sponsors

| <img src="https://avatars.githubusercontent.com/u/91712707?v=4" alt="T2"   width="150px" height="150px" /> | <img src="https://avatars.githubusercontent.com/u/36291011?v=4" alt="Alex Shan"   width="150px" height="150px" /> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [T2-official(T2)](https://github.com/T2-official)            | [Alex Shan](https://github.com/Shan-mx)            |

## Silver Sponsors
| <img src="https://avatars.githubusercontent.com/u/103700780?v=4" alt="IdrilK"  width="150px" height="150px" /> |
| ------------------------------------------------------------ |
| [IdrilK](https://github.com/IdrilK)            |

## Sponsors
| <img src="https://avatars.githubusercontent.com/u/71590526?v=4" alt="Yuji Sakai"  width="150px" height="150px" /> | <img src="https://avatars.githubusercontent.com/u/49630998?v=4" alt="Iara"  width="150px" height="150px" /> |
| ------------------------------------------------------------ |------------------------------------------------------------ |
| [Yuji Sakai (generalfreed)](https://github.com/generalfreed) |[Iara (labiker)](https://github.com/labiker) |

## 시간에 따른 사용자 수

[![시간에 따른 사용자 수](https://starchart.cc/MakinoharaShoko/WebGAL.svg)](https://starchart.cc/MakinoharaShoko/WebGAL)


## 发布日志

**本仓库只发布源代码**

**如果你想要体验使用便捷的图形化编辑器创建、制作并实时预览 WebGAL 游戏，请 [下载 WebGAL 图形化编辑器](https://github.com/MakinoharaShoko/WebGAL_Terre/releases)**

### 在此版本中

#### 新功能

添加唇形同步和眨眼动画

添加启动图

#### 修复

iOS 设备上无法正常进行游戏的异常

文本框在遇到特殊符号时的换行异常

解析器解析 `say` 指令时出现的异常

解析器解析音频文件路径时出现的异常

<!-- English Translation -->
## Release Notes

**This repository only releases source code**

**If you want to create, produce, and preview WebGAL games conveniently with a graphical editor, please [download the WebGAL Graphical Editor](https://github.com/MakinoharaShoko/WebGAL_Terre/releases)**

### In This Version

#### New Features

Added lip sync and blinking animations

Added startup image

#### Fixes

Resolved issues with game not working properly on iOS devices

Fixed text box line breaks when encountering special characters

Resolved exceptions when parser parses `say` commands

Resolved exceptions when parser parses audio file paths

<!-- Japanese Translation -->
## リリースノート

**このリポジトリはソースコードのみをリリースします**

**WebGAL ゲームを便利なグラフィカルエディタで作成、制作、そしてリアルタイムでプレビューしたい場合は、[WebGAL グラフィカルエディタをダウンロードしてください](https://github.com/MakinoharaShoko/WebGAL_Terre/releases)**

### このバージョンで

#### 新機能

リップシンクとまばたきアニメーションを追加

起動画像を追加

#### 修正

iOS デバイスでゲームが正常に動作しない問題を修正

特殊文字に遭遇した際のテキストボックスの改行問題を修正

パーサが `say` コマンドを解析する際の例外を修正

パーサがオーディオファイルパスを解析する際の例外を修正

<!-- French Translation -->
## Notes de version

**Ce dépôt ne publie que du code source**

**Si vous souhaitez créer, produire et prévisualiser des jeux WebGAL de manière pratique avec un éditeur graphique, veuillez [télécharger l'Éditeur Graphique WebGAL](https://github.com/MakinoharaShoko/WebGAL_Terre/releases)**

### Dans cette version

#### Nouvelles fonctionnalités

Ajout de la synchronisation labiale et des animations de clignement

Ajout d'une image de démarrage

#### Corrections

Résolution des problèmes de jeu ne fonctionnant pas correctement sur les appareils iOS

Correction des retours à la ligne dans la zone de texte lors de la rencontre de caractères spéciaux

Résolution des exceptions lorsque le parseur analyse les commandes `say`

Résolution des exceptions lorsque le parseur analyse les chemins de fichiers audio


## Sponsor

| <img src="https://avatars.githubusercontent.com/u/91712707?v=4" alt="T2"  /> |
| ------------------------------------------------------------ |
| [T2-official(T2)](https://github.com/T2-official)            |



## 动画系统设计

在 WebGAL 新版本中，`动画`将会是一个 `PIXI.Ticker` 回调函数。而`变换`则是一个特殊的动画，只不过执行时间是0ms（在动画的第一帧就将舞台对象设置为终态状态）。

除此以外，因为并不是每一个舞台状态都包含动画相关的演出，所以为了在动画结束后也要保持舞台对象处于动画结束后被设置的位置（或应用的效果），还会有一个“内部变换”。

“内部变换”是一连串对指定 key 的舞台对象要应用的效果的记录。“内部变换”调用的时机一般是任何舞台对象动画结束后或舞台对象发生改变时。

为了防止“内部变换”影响舞台对象上动画的正常运行，WebGAL 舞台控制器有一个记录，可以记录下正在进行动画的舞台对象的 key，这些key会被锁定，无法应用变换。直到动画结束后，才会被解锁。

在任何动画结束后，动画执行程序都会将其作用的舞台对象的“终态”更新到对应的 key 的舞台对象的“内部变换”记录上。

## 不同类型的动画

在 WebGAL 中，可以作用在舞台对象上的动画，可以分为即时动画和退出动画。

即时动画会在脚本被调用的时候被立即触发。由于在没有任何动画被设置的情况下，舞台对象会预设一个渐入，所以如果想要自定义渐入动画，只需要在切换立绘/背景后立刻执行一个自定义的即时动画就可以了。

而退出动画将会在立绘/背景被移除时作用。默认的退出动画是一个渐出。如果想要应用一个退出动画，一个比较好的方式是在立绘退出时（在切换或关闭立绘时）为带有后缀 `-off` 的退出舞台对象设置一个即时动画。

所以，无论是进入还是退出动画，都应在 setFigure 或 setBg 后应用，无论这个命令是为了添加还是删除一个立绘。


## 演出调用说明

第一步，语句调用器 `runScript.ts` 根据语句类型执行一个语句，语句会返回一个IPerform对象，并将当前语句的演出写入到场景状态。

第二步，语句调用器 `runScript.ts` 会设定一个自动的计时器，用于结束并卸载对象。

```jstypescript
export interface IPerform {
    performName: string,// 演出名称，用于在后面手动清除演出，如果没有标识，则代表不是保持演出，给予一个随机字符串
    duration: number, // 持续时间，单位为ms，持续时间到后强制设置该演出为“已经结束”状态
    isOver: boolean, //演出是否已经结束
    isHoldOn: boolean, //演出是不是一个保持类型的演出
    stopFunction: Function, // 卸载演出的函数，这个函数不一定要真的卸载演出，只是在演出结束时会默认调用。
    blockingNext: Function // 演出是否阻塞游戏流程继续（一个函数，返回 boolean类型的结果，判断要不要阻塞）
    blockingAuto: Function //演出是否阻塞自动模式（一个函数，返回 boolean类型的结果，判断要不要阻塞）
}
```

第三步，在演出时间抵达时，卸载演出（语句调用器会在指定时间自动卸载），直到演出列表里没有演出（保持演出则不会卸载）

**注意：`isOver` 为 `true` 时，不会阻塞auto和next，这时候不检查 `blockingNext` 与 `blockingAuto`**

当在演出时发生auto调用： auto函数会检查演出列表，如果只存在不阻塞auto的演出，就调用auto。

当在演出时发生next调用： next函数会结束所有可打断演出，卸载演出。 卸载所有非 `HoldOn` 计时器 如果存在阻塞next的演出，next不会响应。

当在自动播放（auto）模式下触发next（用户点击鼠标）

1.检查是否存在阻塞next的演出，否则不响应

2.如果没有被阻塞，那么就停止所有演出，并停止auto


# 界面层级划分（草案）

```js
z-index:组件
 0:备用
 1:舞台背景
 2:备用
 3:pixi 演出
 4:人物立绘
 5:pixi 演出的另一个可选层
 6:文本框
 7:备用
 8:选项与触发的舞台交互
 9:文本框下面的control Panel
10:control Panel 触发的UI（比如快速存读档）
11:视频与全屏演出
12:全屏点击
13:Title 层，覆盖全屏点击的演出层
14:Title 层触发的UI
15:备用
16:Menu层
17:Menu层触发的UI
18:备用
19:游戏引擎进入动画
20:全局对话框
```


```js
WebGAL:这是一条测试语句。 -v1.ogg ;
解析为=> {
    command: commandType.say, //语句类型
    content: '这是一条测试语句。', //语句内容
    args: [
        {
            key: 'vocal', //参数键是语音
            value: './vocal/v1.ogg' //参数值是语音文件路径（由assetSetter 解析）
        },
        {
            key: 'speaker', //参数键是说话人
            value: 'WebGAL' //参数值是说话人名称
        }
    ], //参数列表
    sentenceAssets: [
        {
            name: 'v1.ogg', //资源名称
            type: assetType.audio, //资源类型
            url: './vocal/v1.ogg', //资源url
            lineNumber: 1, //触发资源语句的行号
        }
    ], // 语句携带的资源列表
    subScene: '' // 语句包含子场景
}
```

```js
WebGAL:이것은 테스트 문장입니다. -v1.ogg ;
해석 결과=> {
    command: commandType.say, //문장 유형
    content: '이것은 테스트 문장입니다.', //문장 내용
    args: [
        {
            key: 'vocal', //매개변수 키는 음성
            value: './vocal/v1.ogg' //매개변수 값은 음성 파일 경로( assetSetter에 의해 파싱됨)
        },
        {
            key: 'speaker', //매개변수 키는 화자
            value: 'WebGAL' //매개변수 값은 화자의 이름
        }
    ], //매개변수 목록
    sentenceAssets: [
        {
            name: 'v1.ogg', //자원 이름
            type: assetType.audio, //자원 유형
            url: './vocal/v1.ogg', //자원 url
            lineNumber: 1, //리소스 문장의 행 번호를 트리거
        }
    ], // 문장에 포함된 리소스 목록
    subScene: '' //문장에 포함된 하위 장면
}
```


## 애니메이션 시스템 설계

WebGAL의 새 버전에서 `애니메이션`은 `PIXI.Ticker` 콜백 함수가 될 것입니다. 반면 `변형`은 특별한 애니메이션으로, 실행 시간이 0ms (애니메이션의 첫 프레임에서 스테이지 객체를 최종 상태로 설정)입니다.

게다가, 모든 스테이지 상태가 애니메이션 관련 퍼포먼스를 포함하지 않기 때문에 애니메이션이 끝난 후에도 스테이지 객체가 애니메이션 종료 후 설정된 위치(또는 적용된 효과)를 유지하도록 "내부 변형"이 필요합니다.

"내부 변형"은 지정된 key의 스테이지 객체에 적용할 효과의 연속된 기록입니다. "내부 변형"은 일반적으로 스테이지 객체의 애니메이션이 끝난 후 또는 스테이지 객체가 변경될 때 호출됩니다.

"내부 변형"이 스테이지 객체의 애니메이션 정상 작동에 영향을 주지 않도록 하기 위해, WebGAL 스테이지 컨트롤러는 애니메이션 중인 스테이지 객체의 key를 기록할 수 있습니다. 이러한 key는 잠금되어 변형을 적용할 수 없습니다. 애니메이션이 끝날 때까지 잠금이 해제되지 않습니다.

모든 애니메이션이 끝난 후, 애니메이션 실행 프로그램은 작동하는 스테이지 객체의 "최종 상태"를 해당 key의 스테이지 객체의 "내부 변형" 기록으로 업데이트합니다.

## 다른 유형의 애니메이션

WebGAL에서 스테이지 객체에 적용할 수 있는 애니메이션은 즉시 애니메이션과 종료 애니메이션으로 나눌 수 있습니다.

즉시 애니메이션은 스크립트가 호출되는 즉시 트리거됩니다. 애니메이션이 설정되지 않은 경우 스테이지 객체는 페이드인이라는 기본값을 가지므로, 사용자 정의 페이드인 애니메이션을 원한다면 캐릭터/배경을 바꾼 후 즉시 사용자 정의 애니메이션을 실행하면 됩니다.

반면에 종료 애니메이션은 캐릭터/배경이 제거될 때 적용됩니다. 기본적으로 페이드아웃이 적용되는데, 종료 애니메이션을 적용하려면 `-off` 접미사를 가진 종료 스테이지 객체에 즉시 애니메이션을 설정하는 것이 좋습니다.

따라서, 입장이나 퇴장 애니메이션은 setFigure 또는 setBg가 호출된 후에 적용해야 합니다. 이 명령어가 캐릭터를 추가하거나 삭제하기 위해 사용되는 경우에도 마찬가지입니다.


# 인터페이스 계층 구조(초안)

```js
z-index: 컴포넌트
 0: 예비
 1: 스테이지 배경
 2: 예비
 3: pixi 퍼포먼스
 4: 캐릭터 일러스트
 5: pixi 퍼포먼스의 또 다른 선택적 계층
 6: 텍스트 박스
 7: 예비
 8: 선택 및 트리거 스테이지 상호작용
 9: 텍스트 박스 아래의 control Panel
10: control Panel에서 트리거되는 UI (예: 빠른 저장/불러오기)
11: 비디오 및 전체 화면 퍼포먼스
12: 전체 화면 클릭
13: Title 계층, 전체 화면 클릭의 퍼포먼스 계층을 덮는다
14: Title 계층에서 트리거되는 UI
15: 예비
16: Menu 계층
17: Menu 계층에서 트리거되는 UI
18: 예비
19: 게임 엔진 진입 애니메이션
20: 전역 대화 상자
```


## 퍼포먼스 호출 지침

첫 번째 단계, 문장 호출기 `runScript.ts`는 문장 유형에 따라 문장을 실행하며, 문장은 IPerform 객체를 반환하고 현재 문장의 퍼포먼스를 장면 상태에 기록합니다.

두 번째 단계, 문장 호출기 `runScript.ts`는 객체를 종료하고 언로드하기 위한 자동 타이머를 설정합니다.

```jstypescript
export interface IPerform {
    performName: string, // 퍼포먼스 이름, 이후에 수동으로 퍼포먼스를 제거하기 위해 사용, 표시가 없다면 이는 지속 퍼포먼스가 아니며 랜덤 문자열을 부여받습니다.
    duration: number, // 지속 시간, 단위는 ms, 지속 시간 후에 이 퍼포먼스를 "이미 끝난" 상태로 강제 설정합니다.
    isOver: boolean, // 퍼포먼스가 이미 끝났는지 여부
    isHoldOn: boolean, // 퍼포먼스가 유지 타입의 퍼포먼스인지 여부
    stopFunction: Function, // 퍼포먼스를 언로드하는 함수, 이 함수는 반드시 퍼포먼스를 언로드할 필요는 없지만, 퍼포먼스가 끝날 때 기본적으로 호출됩니다.
    blockingNext: Function // 퍼포먼스가 게임 프로세스를 차단하는지 여부 (함수, boolean 타입의 결과를 반환, 차단할지 여부를 판단)
    blockingAuto: Function // 퍼포먼스가 자동 모드를 차단하는지 여부 (함수, boolean 타입의 결과를 반환, 차단할지 여부를 판단)
}
```

세 번째 단계, 퍼포먼스 시간이 도달하면 퍼포먼스를 언로드합니다(문장 호출기는 지정된 시간에 자동으로 언로드됩니다), 퍼포먼스 목록에 퍼포먼스가 없을 때까지(유지 퍼포먼스는 언로드되지 않습니다)

**참고: `isOver`가 `true`인 경우 auto와 next를 차단하지 않으며, 이때는 `blockingNext`와 `blockingAuto`를 확인하지 않습니다**

퍼포먼스 중에 auto 호출이 발생할 때: auto 함수는 퍼포먼스 목록을 확인하고, auto를 차단하지 않는 퍼포먼스만 존재하면 auto를 호출합니다.

퍼포먼스 중에 next 호출이 발생할 때: next 함수는 모든 중단 가능한 퍼포먼스를 종료하고 퍼포먼스를 언로드합니다. 모든 비 `HoldOn` 타이머를 언로드합니다. next를 차단하는 퍼포먼스가 있으면 next는 반응하지 않습니다.

자동 재생(auto) 모드에서 next가 트리거 될 때(사용자가 마우스를 클릭)

1. next를 차단하는 퍼포먼스가 있는지 확인하고, 그렇지 않으면 응답하지 않습니다

2. 차단되지 않았다면, 모든 퍼포먼스를 중단하고 auto를 중단합니다


# `/packages/parser/rollup.config.js`

This is a Rollup configuration file that generates a JavaScript file for the "webgalParser" module. The file will be included in the output of the Rollup task, and will be compiled with the UMD ( universal module bundler ) format.

It seems that the webgalParser is a library that parse tsconfig.json and generate a global version of tsconfig.json which is used for parsing JSDK config files.

This configuration file is using the Rollup plugin-typescript and rollup-plugin-node-resolve to handle typescript and rollup.


```js
import typescript from "rollup-plugin-typescript2";
import resolve from "@rollup/plugin-node-resolve";
import commonjs from "@rollup/plugin-commonjs";

const mode = process.env.MODE ?? 'prod';
const isProd = mode === "prod";

export default [
  {
    input: `./src/index.ts`,
    output:
      {
        file: "./build/es/index.js",
        format: "es",
        sourcemap: !isProd
      },
    plugins: [
      resolve(), commonjs(), typescript({
        useTsconfigDeclarationDir: true,
        tsconfigOverride: {
          compilerOptions: {
            sourceMap: !isProd,
            declarationDir: "build/es"
          }, include: ["src"]
        }
      })]
  }, {
    input: `./src/index.ts`,
    output: [
      {
        file: "./build/cjs/index.js",
        exports: "named",
        format: "cjs",
        sourcemap: !isProd
      },
    ],
    plugins: [
      resolve(), commonjs(), typescript({
        useTsconfigDeclarationDir: true,
        tsconfigOverride: {
          compilerOptions: {
            sourceMap: !isProd,
            declarationDir: "build/cjs"
          }, include: ["src"]
        }
      })],
  },
  {
    input: `./src/index.ts`,
    output: [
      {
        file: "./build/umd/index.global.js",
        name: 'webgalParser',
        format: 'iife',
        sourcemap: !isProd
      },
    ],
    plugins: [
      resolve(), commonjs(), typescript({
        useTsconfigDeclarationDir: true,
        tsconfigOverride: {
          compilerOptions: {
            sourceMap: !isProd,
            declarationDir: "build/types"
          }, include: ["src"]
        }
      })],
  }
];

```

# `/packages/parser/src/index.ts`

SceneParser is a class that uses scene parsing and script configuration to parse and configure scenes in Node.js. It has the ability to accept an array of assets, which are prefixed with a configurable list of numbers. It also has a script config that can be passed in via a command line argument.

SceneParser has the following instance variables:

* `assetsPrefetcher`: A function that takes an array of assets and preinks their labels
* `assetSetter`: A function that takes a file name and an asset type, and returns the prefixed string
* `ADD_NEXT_ARG_LIST`: An array of numbers that can be passed to `assetPrefetcher` to specify the order in which the assets should be prefixed
* `SCRIPT_CONFIG`: An array of any script related configuration that can be passed in via a command line argument

It has the following methods:

* `parse(rawScene: string, sceneName: string, sceneUrl: string)`: This method parses a scene from a string and returns the parsed scene, with the name and URL modified to match the original scene specified.
* `parseConfig(configText: string)`: This method takes a string representing a scene configuration and returns a parsed config object.
* `stringifyConfig(config: WebgalConfig)`: This method takes a parsed config object and returns a stringify representation of the config object.

It also has an additional method `parseScriptConfig(configText: string)` which parses the config string passed in, and returns the config object.


```js
import {commandType, IAsset} from "./interface/sceneInterface";
import {fileType} from "./interface/assets";
import {sceneParser} from "./sceneParser";
import {ADD_NEXT_ARG_LIST, SCRIPT_CONFIG} from "./config/scriptConfig";
import {configParser, WebgalConfig} from "./configParser/configParser";

export default class SceneParser {

  private readonly assetsPrefetcher;
  private readonly assetSetter;
  private readonly ADD_NEXT_ARG_LIST;
  private readonly SCRIPT_CONFIG;

  constructor(assetsPrefetcher: ((assetList: Array<IAsset>) => void),
              assetSetter: (fileName: string, assetType: fileType) => string,
              ADD_NEXT_ARG_LIST: Array<number>, SCRIPT_CONFIG: Array<any>) {
    this.assetsPrefetcher = assetsPrefetcher;
    this.assetSetter = assetSetter;
    this.ADD_NEXT_ARG_LIST = ADD_NEXT_ARG_LIST;
    this.SCRIPT_CONFIG = SCRIPT_CONFIG;
  }

  parse(rawScene: string, sceneName: string, sceneUrl: string
  ) {
    return sceneParser(rawScene, sceneName, sceneUrl, this.assetsPrefetcher, this.assetSetter, this.ADD_NEXT_ARG_LIST, this.SCRIPT_CONFIG);
  }

  parseConfig(configText: string) {
    return configParser(configText)
  }

  stringifyConfig(config: WebgalConfig) {
    return config
      .reduce(
        (previousValue, curr) =>
          (previousValue + `${curr.command}:${curr.args.join('|')}${curr.options.length <= 0 ? '' : curr.options.reduce((p, c) => (p + ' -' + c.key + '=' + c.value), '')};\n`),
        ''
      )
  }
}

```

该代码导出了两个对象，分别是 `ADD_NEXT_ARG_LIST` 和 `SCRIPT_CONFIG`。

`ADD_NEXT_ARG_LIST` 是一个数组，包含了通过 `console.log()` 函数输出的一些字符串，这些字符串描述了允许通过 `--` 标志传递给该函数的选项。这些选项包括 `--describe`，`--all`, `--color` 和 `--extend-describe`。

`SCRIPT_CONFIG` 是一个对象，其中包含了一些关于配置脚本信息的属性。例如，它可能包含 `__file` 属性，用于指示脚本文件的相对路径，以及 `__dirname` 属性，用于指示脚本文件所在的目录。


```js
export {ADD_NEXT_ARG_LIST, SCRIPT_CONFIG};

```

# `/packages/parser/src/sceneParser.ts`

这段代码定义了一个`IScene`接口的类`SceneDecoder`，用于将原始场景(`rawScene`)、场景名称(`sceneName`)、场景URL(`sceneUrl`)、资源预处理程序(`assetsPrefetcher`)、资源设置程序(`assetSetter`)、添加的下一级参数列表(`ADD_NEXT_ARG_LIST`)和脚本配置(`SCRIPT_CONFIG`)解析成一个具体的场景对象(`IScene`)。

具体来说，这段代码做了以下几件事情：

1. 导入了一些外部接口`IAsset`、`IScene`和`ISentence`，以及一个用于将原始场景转换为JSON的函数`scriptParser`。

2. 定义了一个`SceneDecoder`类，该类实现了`IScene`接口。

3. `SceneDecoder`类包含了一个私有属性`rawScene`，一个私有属性`sceneName`，一个私有属性`sceneUrl`，和一个私有属性`assetsPrefetcher`，以及一个私有属性`assetSetter`。这些属性用于保存原始场景、场景名称、场景URL、资源预处理程序和资源设置程序，以及定义场景中使用的资源。

4. `SceneDecoder`类包含了一个私有方法`decodeScene`，该方法将解析原始场景为指定的场景类型。

5. `decodeScene`方法实现了两个参数：`scene`和`options`。其中，`scene`参数是一个可选的`IScene`对象，用于保存解析后的场景信息；`options`参数是一个选项对象，用于保存解析场景时需要设置的选项。

6. `decodeScene`方法的具体实现如下：

```jsjavascript
/**
* 解析原始场景为指定场景类型
* @param scene 需要解析的场景
* @param options 解析场景时需要设置的选项
* @returns {IScene} 解析后的场景
*/
async function decodeScene(scene, options = {}) {
 // 解析场景类型
 const sceneType = await this.parser.parse(scene, {
   config: {
     type: fileType.SCENE,
     scene: scene.trim()
   }
 });

 // 解析场景名称、场景URL和资源预处理程序
 const sceneName = await this.parser.parse(
   `${sceneType.name}.${sceneType.extension}`,
   { config: { name: true, extensions: ['.json'] } }
 );
 const sceneUrl = sceneType.url;

 // 解析资源设置程序
 const assetsPrefetcher = options.assetsPrefetcher;

 // 解析资源设置
 const assetSetter = options.assetSetter;

 // 解析下一级参数
 const nextArgs = options.ADD_NEXT_ARG_LIST || [];

 // 解析脚本配置
 const scriptConfig = options.SCRIPT_CONFIG;

 // 将解析到的场景信息保存起来
 return {
   name: sceneName,
   url: sceneUrl,
   assetsPrefetcher,
   assetSetter,
   nextArgs,
   scriptConfig
 };
}
```

这段代码的作用是将一个原始场景(可以是一个JSON对象)解析为指定的场景类型(可以是JSON对象、 Scene对象、Stage对象)，并返回解析后的场景对象。该场景对象包含了场景名称、场景URL、资源预处理程序和资源设置程序、以及定义场景中使用的资源等属性。


```js
import { IAsset, IScene, ISentence } from "./interface/sceneInterface";
import { scriptParser } from "./scriptParser/scriptParser";
import uniqWith from "lodash/uniqWith";
import { fileType } from "./interface/assets";

/**
 * 场景解析器
 * @param rawScene 原始场景
 * @param sceneName 场景名称
 * @param sceneUrl 场景url
 * @param assetsPrefetcher
 * @param assetSetter
 * @param ADD_NEXT_ARG_LIST
 * @param SCRIPT_CONFIG
 * @return {IScene} 解析后的场景
 */
```

这段代码定义了一个名为sceneParser的函数，它接受一个原始场景、场景名称、场景URL以及一个函数作为资产预加载处理程序。这个函数内部包含了多个判断和map操作，最终返回一个 Scene 对象。

具体来说，这段代码的功能如下：

1. 将输入的原始场景字符串分割成一个个语句，去除每个语句中的空格，并将分割出的语句放入一个名为assetsList的数组中。
2. 对assetsList数组进行去重，然后传递给资产预加载处理程序。
3. 如果assetsList数组长度为0，则不执行资产预加载，直接返回一个空数组。
4. 返回一个 Scene 对象，包含场景名称、场景URL、语句列表、以及处理后的资产列表和子场景列表。


```js
export const sceneParser = (rawScene: string, sceneName: string, sceneUrl: string
  , assetsPrefetcher: ((assetList: Array<IAsset>) => void), assetSetter: (fileName: string, assetType: fileType) => string
  , ADD_NEXT_ARG_LIST: any, SCRIPT_CONFIG: any): IScene => {
  const rawSentenceList = rawScene.split("\n"); // 原始句子列表

  // 去分号留到后面去做了，现在注释要单独处理
  const rawSentenceListWithoutEmpty = rawSentenceList;
  // .map((sentence) => sentence.split(";")[0])
  // .filter((sentence) => sentence.trim() !== "");
  let assetsList: Array<IAsset> = []; // 场景资源列表
  let subSceneList: Array<string> = []; // 子场景列表
  const sentenceList: Array<ISentence> = rawSentenceListWithoutEmpty.map((sentence) => {
    const returnSentence: ISentence = scriptParser(sentence, assetSetter, ADD_NEXT_ARG_LIST, SCRIPT_CONFIG);
    // 在这里解析出语句可能携带的资源和场景，合并到 assetsList 和 subSceneList
    assetsList = [...assetsList, ...returnSentence.sentenceAssets];
    subSceneList = [...subSceneList, ...returnSentence.subScene];
    return returnSentence;
  });

  // 开始资源的预加载
  assetsList = uniqWith(assetsList); // 去重
  assetsPrefetcher(assetsList);

  return {
    sceneName: sceneName, // 场景名称
    sceneUrl: sceneUrl,
    sentenceList: sentenceList, // 语句列表
    assetsList: assetsList, // 资源列表
    subSceneList: subSceneList // 子场景列表
  };
};

```

# `/packages/parser/src/config/scriptConfig.ts`

It appears that the script you provided is a series of commands for changing animations and other aspects of the game. The script is structured as a series of objects, each of which has a `scriptString` property that specifies the script name and a `scriptType` property that specifies the type of script. The `scriptType` can be one of several possible values, including `commandType.changeBg`, `commandType.changeFigure`, `commandType.changeScene`, `commandType.choose`, `commandType.end`, `commandType.bgm`, `commandType.video`, `commandType.setComplexAnimation`, `commandType.setFilter`, `commandType.pixiInit`, `commandType.pixi`, `commandType.label`, `commandType.jumpLabel`, `commandType.setVar`, `commandType.callScene`, `commandType.showVars`, `commandType.unlockCg`, `commandType.unlockBgm`, `commandType.say`, `commandType.filmMode`, `commandType.callScene`, `commandType.setTextbox`, `commandType.setAnimation`, `commandType.playEffect`, and others.

It's important to note that these commands are intended to be used by a game developer, and the specific implementation of these commands may vary depending on the game engine or other environment in which the commands are being used. Additionally, using these commands may require a certain level of familiarity with the game development process, as well as an understanding of the various types of animations and other effects that can be achieved through the use of these commands.


```js
import { commandType } from "../interface/sceneInterface";

export const SCRIPT_CONFIG = [
  { scriptString: 'intro', scriptType: commandType.intro },
  { scriptString: 'changeBg', scriptType: commandType.changeBg },
  { scriptString: 'changeFigure', scriptType: commandType.changeFigure },
  { scriptString: 'miniAvatar', scriptType: commandType.miniAvatar },
  { scriptString: 'changeScene', scriptType: commandType.changeScene },
  { scriptString: 'choose', scriptType: commandType.choose},
  { scriptString: 'end', scriptType: commandType.end },
  { scriptString: 'bgm', scriptType: commandType.bgm },
  { scriptString: 'playVideo', scriptType: commandType.video },
  {
    scriptString: 'setComplexAnimation',
    scriptType: commandType.setComplexAnimation,
  },
  { scriptString: 'setFilter', scriptType: commandType.setFilter },
  { scriptString: 'pixiInit', scriptType: commandType.pixiInit },
  { scriptString: 'pixiPerform', scriptType: commandType.pixi },
  { scriptString: 'label', scriptType: commandType.label},
  { scriptString: 'jumpLabel', scriptType: commandType.jumpLabel},
  { scriptString: 'setVar', scriptType: commandType.setVar },
  { scriptString: 'callScene', scriptType: commandType.callScene },
  { scriptString: 'showVars', scriptType: commandType.showVars },
  { scriptString: 'unlockCg', scriptType: commandType.unlockCg },
  { scriptString: 'unlockBgm', scriptType: commandType.unlockBgm },
  { scriptString: 'say', scriptType: commandType.say },
  { scriptString: 'filmMode', scriptType: commandType.filmMode },
  { scriptString: 'callScene', scriptType: commandType.callScene },
  { scriptString: 'setTextbox', scriptType: commandType.setTextbox},
  { scriptString: 'setAnimation', scriptType: commandType.setAnimation },
  { scriptString: 'playEffect', scriptType: commandType.playEffect },
];
```

以上代码定义了一个名为`ADD_NEXT_ARG_LIST`的常量数组，数组中共有11个元素，类型均为`commandType`。数组中的元素涵盖了命令类型的一些常见类型，包括`bgm`、`pixi`、`pixiInit`、`label`、`if`、`miniAvatar`、`setVar`、`unlockBgm`、`unlockCg`、`filmMode`和`playEffect`。这些元素的作用可以根据具体上下文来确定。


```js
export const ADD_NEXT_ARG_LIST = [
  commandType.bgm,
  commandType.pixi,
  commandType.pixiInit,
  commandType.label,
  commandType.if,
  commandType.miniAvatar,
  commandType.setVar,
  commandType.unlockBgm,
  commandType.unlockCg,
  commandType.filmMode,
  commandType.playEffect,
];

```

# `/packages/parser/src/configParser/configParser.ts`

这段代码定义了一个名为 `WebgalConfig` 的接口 `WebgalConfig` 类型，该类型包含一个或多个 `IConfigItem` 对象。

`argsParser` 函数可能是一个类，用于解析命令行参数，该函数可能会接受一个或多个参数，这些参数可能是一个类的实例，该类继承自 `argsParser` 类。

`IConfigItem` 接口定义了一个配置项的抽象类。

`WebgalConfig` 接口定义了一个 Webgal 项目的配置项数组，该数组可能包含一个或多个 `IConfigItem` 对象。

`WebgalConfig` 接口还定义了一个名为 `options` 的属性，它的类型为 `IOptionItem[]`，可能是一个类，用于存储配置项的选项，该类继承自 `IOptionItem` 类。


```js
import {argsParser} from "../scriptParser/argsParser";

interface IOptionItem{
  key:string;
  value:string | number | boolean;
}
interface IConfigItem{
  command:string;
  args:string[]
  options:IOptionItem[];
}

export type WebgalConfig = IConfigItem[]


```



这段代码定义了一个名为 `configLineParser` 的函数，用于解析输入行中的选项和命令，返回一个表示配置项的对象。

函数接受一个输入行参数 `inputLine`。首先，将输入行中的注释标记去除，如果输入行是空字符串，则返回一个表示配置项的空对象 `{}`。

如果输入行包含命令和参数，则解析命令并将其存储在 `command` 变量中。如果解析参数成功，则将其存储在 `args` 数组中。如果解析命令失败，则返回 `{}`。

函数使用 `argsParser` 函数来解析 `options` 数组中的参数。`argsParser` 函数接收一个参数 `optionsRaw`，它是一个表示选项的原始字符串。函数返回一个解析后的参数数组，每个元素都是一个只包含参数名称的选项对象。如果 `optionsRaw` 包含参数，则先将其去重，然后将其存储在 `options` 数组中。

函数最终返回一个表示配置项的对象 `{command, args, options}`。


```js
function configLineParser(inputLine:string):IConfigItem{
  const options:Array<IOptionItem> = [];
  let command: string;

  let newSentenceRaw = inputLine.split(";")[0];
  if (newSentenceRaw === "") {
    // 注释提前返回
    return {
      command:'',
      args:[],
      options:[]
    };
  }
  // 截取命令
  const getCommandResult = /:/.exec(newSentenceRaw);

  // 没有command
  if (getCommandResult === null) {
    command = '';
  } else {
    command = newSentenceRaw.substring(0, getCommandResult.index);
    // 划分命令区域和content区域
    newSentenceRaw = newSentenceRaw.substring(getCommandResult.index + 1, newSentenceRaw.length);
  }
  // 截取 Options 区域
  const getOptionsResult = / -/.exec(newSentenceRaw);
  // 获取到参数
  if (getOptionsResult) {
    const optionsRaw = newSentenceRaw.substring(getOptionsResult.index, newSentenceRaw.length);
    newSentenceRaw = newSentenceRaw.substring(0, getOptionsResult.index);
    for (const e of argsParser(optionsRaw, (name,_)=>{return name})) {
      options.push(e);
    }
  }
  return {
    command,
    args:newSentenceRaw.split('|').map(e=>e.trim()).filter(e=>e!==''),
    options
  };
}

```

这段代码定义了一个名为 `configParser` 的函数，它接受一个字符串参数 `configText`。这个函数的作用是将给定的 `configText` 字符串解析为一个 `WebgalConfig` 对象，使得我们可以对其中的配置行进行进一步的处理。

函数的核心部分是：
```jsjavascript
const configLines = configText.replaceAll(`\r`,'').split('\n');
```
首先，我们使用正则表达式将给定的 `configText` 字符串中的所有换行符和转义字符串 (即 `\r`) 删除，并返回一个包含所有剩余配置行的字符串数组。
```jscss
const configLines = configText.replaceAll(`\r`,'').split('\n');
```
接下来，我们使用 `map` 方法对上述结果进行迭代，并将其中的每一个元素传递给 `configLineParser` 函数。由于 `configLineParser` 函数接受一个参数 `e`，我们为这个函数指定一个空括号 `{}`，以便将其扩展为接受 `e` 参数的函数。
```jsscss
return configLines.map(e=>configLineParser(e)).filter(e=>e.command!=='');
```
最后，我们使用 `filter` 方法筛选出 `configLines` 数组中的所有元素，这些元素都是 `configLineParser` 函数的输出，而不仅仅是 `!` 符号左边的字符串。这个筛选之后的结果被返回，作为最后一个参数，给定了 `configParser` 函数。


```js
export function configParser(configText:string):WebgalConfig{
  const configLines = configText.replaceAll(`\r`,'').split('\n');
  return configLines.map(e=>configLineParser(e)).filter(e=>e.command!=='');
}

```

# `/packages/parser/src/interface/assets.ts`

这段代码定义了一个名为 `fileType` 的枚举类型，列举了 8 种常见的文件类型，分别为：

- `background`：背景图片或纹理
- `bgm`：背景音乐或纹理
- `figure`：游戏中的模型或场景
- `scene`：游戏中的场景或构图
- `tex`：纹理图片或音频
- `vocal`：游戏中的声音效果或合成
- `video`：视频或动画

使用这个枚举可以让游戏的开发者更好地了解游戏中的不同元素，例如背景、音效、模型等，以及它们在游戏中的作用。


```js
/**
 * 内置资源类型的枚举
 */
export enum fileType {
  background,
  bgm,
  figure,
  scene,
  tex,
  vocal,
  video,
}

```

# `/packages/parser/src/interface/runtimeInterface.ts`

这段代码定义了一个名为"sceneEntry"的接口，用于场景的进入和退出。

出口（entry）场景的代码块中，定义了一个包含"sceneName"、"sceneUrl"和"continueLine"属性的对象，它们用于场景的描述。

这里的"sceneName"表示进入场景的名称，是一个字符串类型的变量；"sceneUrl"表示场景的URL，是一个字符串类型的变量；"continueLine"表示从原场景继续的行号，是一个整数类型的变量。

此外，还有一个未定义的"continue"方法，它没有明确的定义，但可以根据其名称推测可能是用于继续场景的代码。


```js
/**
 * 子场景结束后回到父场景的入口
 * @interface sceneEntry
 */
export interface sceneEntry {
  sceneName: string; // 场景名称
  sceneUrl: string; // 场景url
  continueLine: number; // 继续原场景的行号
}

```

# `/packages/parser/src/interface/sceneInterface.ts`

这是一段 TypeScript 代码，定义了一个枚举类型 commandType，包含了 16 个不同的命令类型。

命令类型枚举类型表示了应用程序中不同的操作，每个命令类型都被封装为一个常量，使得应用程序在编译时就能明确不同操作之间的含义。

通过枚举类型，我们可以列举出所有可能的命令类型，然后根据需要选择相应的命令来执行。


```js
/**
 * 语句类型
 */
import {sceneEntry} from "./runtimeInterface";
import {fileType} from "./assets";

export enum commandType {
  say, // 对话
  changeBg, // 更改背景
  changeFigure, // 更改立绘
  bgm, // 更改背景音乐
  video, // 播放视频
  pixi, // pixi演出
  pixiInit, // pixi初始化
  intro, // 黑屏文字演示
  miniAvatar, // 小头像
  changeScene, // 切换场景
  choose, // 分支选择
  end, // 结束游戏
  setComplexAnimation, // 动画演出
  setFilter, // 设置效果
  label, // 标签
  jumpLabel, // 跳转标签
  chooseLabel, // 选择标签
  setVar, // 设置变量
  if, // 条件跳转
  callScene, // 调用场景
  showVars,
  unlockCg,
  unlockBgm,
  filmMode,
  setTextbox,
  setAnimation,
  playEffect,
  setTempAnimation,
  comment,
  setTransform,
  setTransition,
}

```

该代码定义了两个接口：arg和IAsset。

arg接口定义了一个单个参数，包括一个参数键和参数值。

IAsset接口定义了一个资源，包括资源名称、类型、资源和url，以及一个行号，用于触发资源语句的位置。


```js
/**
 * 单个参数接口
 * @interface arg
 */
export interface arg {
  key: string; // 参数键
  value: string | boolean | number; // 参数值
}

/**
 * 资源接口
 * @interface IAsset
 */
export interface IAsset {
  name: string; // 资源名称
  type: fileType; // 资源类型
  url: string; // 资源url
  lineNumber: number; // 触发资源语句的行号
}

```



这两段代码定义了一个ISentence和IScene两个接口，用于描述一条语句和一个场景的属性。

ISentence接口定义了命令类型、命令原始内容、语句内容和参数列表等属性，同时提供了将命令和参数列表绑定在一起的机制，方便用户在场景中使用命令。

IScene接口定义了场景属性和场景中角色、权限等相关属性，同时提供了场景中命令和参数的列表，用于在场景中执行命令操作。

两个接口都使用了@interface关键字定义，表示它们是推荐定义的接口类型。在项目中，用户可以根据需要使用这两个接口来定义、使用和管理语句和场景。


```js
/**
 * 单条语句接口
 * @interface ISentence
 */
export interface ISentence {
  command: commandType; // 语句类型
  commandRaw: string; // 命令的原始内容，方便调试
  content: string; // 语句内容
  args: Array<arg>; // 参数列表
  sentenceAssets: Array<IAsset>; // 语句携带的资源列表
  subScene: Array<string>; // 语句包含子场景列表
}

/**
 * 场景接口
 * @interface IScene
 */
```

这段代码定义了一个接口 `IScene` 和一个类 `ISceneData`。

`IScene` 接口表示一个场景，包含场景名称、场景 URL 和语句列表三个属性。

`ISceneData` 类实现了 `IScene` 接口，并添加了两个属性 `currentScene` 和 `sentenceList`，以及一个子属性 `subSceneList`。

`currentScene` 属性保存了当前的场景数据，是一个包含场景元数据的对象，可以设置为引用。`sentenceList` 属性是一个包含当前场景中所有句子的数组。`subSceneList` 属性是一个包含当前场景子场景的 URL 列表。

此外，`ISceneData` 类还定义了一个 `ISceneEntry` 类，该类实现了 `IAssetEntry` 接口，用于在场景中查找资产。


```js
export interface IScene {
  sceneName: string; // 场景名称
  sceneUrl: string; // 场景url
  sentenceList: Array<ISentence>; // 语句列表
  assetsList: Array<IAsset>; // 资源列表
  subSceneList: Array<string>; // 子场景的url列表
}

/**
 * 当前的场景数据
 * @interface ISceneData
 */
export interface ISceneData {
  currentSentenceId: number; // 当前语句ID
  sceneStack: Array<sceneEntry>; // 场景栈
  currentScene: IScene; // 当前场景数据
}

```

这段代码定义了一个名为 "parsedCommand" 的接口，用于表示经过处理的命令接口。

在这个接口中，有两个属性：

* "type"，表示命令的类型，可以是 "null"、"append" 或 "modify"，具体含义如下：
	+ "null"：表示不去做任何操作，返回的仅仅是命令的简要描述；
	+ "append"：表示将命令的附加参数添加到给定的 "arguments" 数组中，生成新的 "arguments" 数组；
	+ "modify"：表示替换给定的 "arguments" 数组中的参数，生成新的 "arguments" 数组。

* "additionalArgs"，表示命令可以传递给它的用户定义附加参数。

此外，还有一个名为 "parsedCommandClass" 的类，用于实现 "parsedCommand" 接口。这个类接收一个可选的 "type" 参数，用于指定要执行的操作，以及一个可选的 "additionalArgs" 参数，用于传递给命令的附加参数。


```js
/**
 * 处理后的命令接口
 * @interface parsedCommand
 */
export interface parsedCommand {
  type: commandType;
  additionalArgs: Array<arg>;
}

```

# `/packages/parser/src/parser4/index.ts`

这段代码定义了一个名为 `jsonGrammarOnlyExample` 的函数，它返回了一个只包含语法定义的 Markup 对象。

Markup 对象包含以下成员：

* `createToken`：用于定义新的 JSON 语法定义的函数，它接收一个 JSON 字符串作为参数，返回一个表示该字符串的 JSON 节点。
* `Lexer`：用于定义 JSON 文件的解析函数，它接收一个 JSON 文件路径和 `createToken` 函数作为参数，返回一个 `chevrotain.兰丘` 对象，该对象包含可以解析的 JSON 语法定义。
* `True`：定义了一个名为 `True` 的 JSON 节点，它包含一个 `createToken` 函数，用于定义一个简单的 true/false 逻辑。
* `False`：定义了一个名为 `False` 的 JSON 节点，它包含一个 `createToken` 函数，用于定义一个简单的 true/false 逻辑。
* `LCurly`：定义了一个名为 `LCurly` 的 JSON 节点，它包含一个 `createToken` 函数，用于定义一个左括号字符。
* `RCurly`：定义了一个名为 `RCurly` 的 JSON 节点，它包含一个 `createToken` 函数，用于定义一个右括号字符。
* `LSquare`：定义了一个名为 `LSquare` 的 JSON 节点，它包含一个 `createToken` 函数，用于定义一个方括号字符。
* `RSquare`：定义了一个名为 `RSquare` 的 JSON 节点，它包含一个 `createToken` 函数，用于定义一个反斜杠字符。
* `Comma`：定义了一个名为 `Comma` 的 JSON 节点，它包含一个 `createToken` 函数，用于定义一个逗号字符。
* `Colon`：定义了一个名为 `Colon` 的 JSON 节点，它包含一个 `createToken` 函数，用于定义一个冒号字符。
* `Lf`：定义了一个名为 `LF` 的 JSON 节点，它包含一个 `createToken` 函数，用于定义一个换行符字符。
* `Semi`：定义了一个名为 `Semi` 的 JSON 节点，它包含一个 `createToken` 函数，用于定义一个分号字符。


```js
// (function jsonGrammarOnlyExample() {
//   // ----------------- Lexer -----------------
//   const createToken = chevrotain.createToken;
//   const Lexer = chevrotain.Lexer;
//
//   const True = createToken({ name: "True", pattern: /true/ });
//   const False = createToken({ name: "False", pattern: /false/ });
//   const LCurly = createToken({ name: "LCurly", pattern: /{/ });
//   const RCurly = createToken({ name: "RCurly", pattern: /}/ });
//   const LSquare = createToken({ name: "LSquare", pattern: /\[/ });
//   const RSquare = createToken({ name: "RSquare", pattern: /]/ });
//   const Comma = createToken({ name: "Comma", pattern: /,/ });
//   const Colon = createToken({ name: "Colon", pattern: /:/ });
//   const Lf = createToken({ name: "LF", pattern: /\n/ });
//   const Semi = createToken({ name: ";", pattern: /;/ });
```

这段代码定义了几个不同类型的 token，包括 Command、Argument、StringLiteral 和 NumberLiteral 类型的 token。

Command 类型的 token 被定义为一个具有 name 属性的对象，其中 name 的值为 "Command"，pattern 为 /Command/。这意味着该 token 将匹配任何以 "Command" 为前缀的字符串。

Argument 类型的 token 被定义为一个具有 name 属性的对象，其中 name 的值为 "-"，pattern 为 /-/。这意味着该 token 将匹配任何以 "-" 为前缀的字符串。

StringLiteral 类型的 token 被定义为一个具有 name 属性的对象，其中 name 的值为 "StringLiteral"，pattern 为 /(?!(?:true|false|Command)\b)\w+/。这意味着该 token 将匹配任何以 "StringLiteral" 为前缀的字符串，除非它同时包含 "true" 或 "false" 或 "Command"。

NumberLiteral 类型的 token 被定义为一个具有 name 属性的对象，其中 name 的值为 "-?"，pattern 为 /-?(0|[1-9]\d*)(\.\d+)?/。这意味着该 token 将匹配任何以 "NumberLiteral" 为前缀的，至少包含一个0和一个1到9之间的数字的字符串，可能包含一个点（.）或下划线（-），但不是 "string" 或者 "boolean" 类型的字符串。


```js
//   const Command = createToken({ name: "Command", pattern: /Command/ });
//   const ArgS = createToken({ name: " -", pattern: / -/ });
//   const StringLiteral = createToken({
//     name: "StringLiteral", pattern: /(?!(?:true|false|Command)\b)\w+/
//   });
//   const NumberLiteral = createToken({
//     name: "NumberLiteral", pattern: /-?(0|[1-9]\d*)(\.\d+)?([eE][+-]?\d+)?/
//   });
//
//   const Equal = createToken({
//     name: "=",
//     pattern: /=/
//   });
//
//   const webgalTokens = [NumberLiteral, StringLiteral, RCurly, LCurly,
```

这段代码定义了一个JavaScript常量数组LSquare, RSquare, Comma, Colon, True, False, Equal, Command, ArgS, Lf, Semi。数组中的每个元素都是一个字符串常量，包括一些JavaScript保留字，如LSquare, RSquare, Comma, Colon, True, False等等。

数组LSquare, RSquare, RSquare包含了一些保留字，可能是用于格式化标记的保留字。LSquare和RSquare可能用于表示文本文本中的标点符号。RSquare可能用于表示符号的优先级。

Command是一个保留字，可能是用于某种形式的命令行输入或输出。

ArgS是一个保留字，可能是用于参数传递给某个函数或方法。

Lf是一个保留字，可能是用于表示一个逻辑真假的字段。

Semi是一个保留字，可能是用于表示编程语言中的Semi类型。

整段代码看起来像是一个JavaScript库或框架的定义，其中的保留字和标点符号都有特殊的含义。但具体的用途和含义需要结合具体的上下文来确定。


```js
//     LSquare, RSquare, Comma, Colon, True, False, Equal, Command, ArgS, Lf, Semi];
//
//   const WebGalLexer = new Lexer(webgalTokens, {
//     // Less position info tracked, reduces verbosity of the playground output.
//     positionTracking: "onlyStart"
//   });
//
//   // Labels only affect error messages and Diagrams.
//   LCurly.LABEL = "'{'";
//   RCurly.LABEL = "'}'";
//   LSquare.LABEL = "'['";
//   RSquare.LABEL = "']'";
//   Comma.LABEL = "','";
//   Colon.LABEL = "':'";
//
```

这段代码定义了一个名为 "webgalScriptParser" 的类，该类继承自 "chevrotain.CstParser" 类。这个类的构造函数包含以下内容：

1. 调用父类的构造函数，传递一个参数 "webgalTokens"，以及一个包含两个属性的对象 "{recoveryEnabled: true}":

   super(webgalTokens, {
       recoveryEnabled: true
   });

2. 在自己的构造函数中，定义一个名为 "webgalScriptParser" 的类，包含以下内容：

   const $ = this;

3. 在 "webgalScriptParser" 的 "RULE" 方法中，定义了一个名为 "scene" 的方法，该方法包含以下内容：

   $.RULE("scene", () => {
       $.MANY_SEP({
           SEP: Lf, DEF: () => {
               // do something with the given webgalTokens object
           }
       });
   });
});

// 可以将此代码编译为 chevrotain.js 文件，然后将其导入到您的 chevrotain 安装中
// chevrotain.js!
// const CstParser = chevrotain.CstParser;
// class webgalScriptParser extends CstParser {
//     constructor() {
//       super(webgalTokens, {
//         recoveryEnabled: true
//       });
//
//       const $ = this;
//
//       $.RULE("scene", () => {
//         $.MANY_SEP({
//           SEP: Lf, DEF: () => {
```js


```
//
//   // ----------------- parser -----------------
//   const CstParser = chevrotain.CstParser;
//
//   class webgalScriptParser extends CstParser {
//     constructor() {
//       super(webgalTokens, {
//         recoveryEnabled: true
//       });
//
//       const $ = this;
//
//       $.RULE("scene", () => {
//         $.MANY_SEP({
//           SEP: Lf, DEF: () => {
```js

这段代码是一个 JavaScript 脚本，使用了 jQuery 库中的 `$.SUBRULE` 和 `$.RULE` 函数。

具体来说，这段代码实现了一个简单的订阅功能，当句子中包含某些特定的词时，提交表单将被提交到服务器。这里订阅的是 `$.sentence` 路由，因此只需要在词出现在 `sentence` 路由的查询对象中时，才会触发提交表单。

具体实现可以分为以下几个步骤：

1. 定义了一个名为 `$.SUBRULE` 的函数，它是 jQuery 的 `$.subscribe` 函数的子函数，可以用来订阅特定路由的变化。

2. 在 `sentence` 路由的定义中，使用 `$.SUBRULE` 函数来订阅 `$.sentence` 路由的变化。

3. 在 `commonSentence` 函数中，使用 `$.SUBRULE` 函数来订阅 `$.commandSentence` 路由的变化。注意，这里使用 `$.OR` 函数来订阅 `commonSentence` 和 `$.commandSentence` 两个路由的变化，因为它们有些路由相同，但可以通过 `$.RULE` 函数进行区分。

4. 在 `submitForm` 的 `append` 事件处理程序中，使用 `$.SUBRULE` 函数来订阅 `$.sentence` 路由的变化，并在词出现在 `sentence` 路由的查询对象中时触发提交表单。

这段代码的作用是实现了一个简单的订阅功能，当句子中包含特定的词时，提交表单将被提交到服务器。


```
//             $.SUBRULE($.sentence);
//           }
//         });
//       });
//
//       $.RULE("sentence", () => {
//         $.OR([
//           { ALT: () => $.SUBRULE($.commonSentence) },
//           { ALT: () => $.SUBRULE($.comment) }
//         ]);
//       });
//
//       $.RULE("commonSentence", () => {
//         $.OR([
//           { ALT: () => $.SUBRULE($.commandSentence) },
```js

这段代码是一个 JavaScript 代码片段，描述了一个自定义对话框的交互作用。这里通过 `$.dialog()` 函数来实现一个带参数控制的问题，通过 `$.SUBRULE()` 方法将 `$.dialog()` 的隐藏选项菜单与 `$.CONSUME()` 选项组合在一起，从而实现了一个带参数选项菜单的对话框。通过 `$.OPTION()` 方法，可以设置选项菜单的显示或隐藏。通过 `$.RULE()` 方法，定义了自定义的对话框规则，包括允许菜单选项的类型（如字符串、数字等）。通过 `$.CONSUME()` 方法，让菜单选项可以被点击或者输入。


```
//           { ALT: () => $.SUBRULE($.dialog) }
//         ]);
//         $.OPTION(() => {
//           $.CONSUME(Semi);
//         });
//       });
//
//       $.RULE("comment", () => {
//         $.CONSUME(Semi);
//         $.CONSUME(StringLiteral);
//       });
//
//       $.RULE("dialog", () => {
//         $.CONSUME(StringLiteral);
//
```js

这段代码是一个 JavaScript 代码片段，描述了一个命令级表达式（Command）的用法。请注意，不要在代码输出中包含源代码，因为这将显示出一部分代码。

这里是一个简化的 RxJS 用法示例：
```javascript
// 将一系列命令级表达式编译成订阅模式，存储在 $.RULE() 函数中
const commandSentence = () => {
 return $.CONSUME(Command)
   .CONSUME(Colon)
   .CONSUME(StringLiteral)
   .OPTION(() => {
     return $.SUBRULE($.args);
   });
};

// 定义一系列命令级表达式
const args = () => {
 return $.CONSUME(ArgS)
   .MANY_SEP({
     __效用： arg,
   });
};
```js
这段代码定义了一个命令级表达式 `commandSentence`，它包含多个观察者（Command）和一个选项（Optional）观察者（.OPTION）。通过组合这些观察者，可以创建一个命令级表达式并订阅它的结果。


```
//       });
//
//
//       $.RULE("commandSentence", () => {
//         $.CONSUME(Command);
//         $.CONSUME(Colon);
//         $.CONSUME(StringLiteral);
//         $.OPTION(() => {
//           $.SUBRULE($.args);
//         });
//       });
//
//       $.RULE("args", () => {
//         $.CONSUME(ArgS);
//         $.MANY_SEP({
```js

这段代码是一个 JavaScript 代码片段，定义了一个名为 "SEP" 的函数，它的含义是 " ArgS, DEF: () => {...}"，其中 "SEP" 函数接受一个参数 "ArgS"，并返回一个匿名函数 "() => {...}"。

这个匿名函数中包含了一系列的 jQuery 规则，对传入的 "ArgS" 参数进行了转换，将其转换成了一个合格的 JavaScript 函数表达式。这些规则分别是：

1. 使用 jQuery 内置的 "arg" 函数，它会接收一个可迭代对象 "argv"(可能是命令行参数)，并返回它的第一个元素(如果存在)，或者返回 `null` 如果 "argv" 对象不存在。
2. 使用 jQuery 内置的 "CONSUME" 函数，它接收两个参数，第一个参数是一个字符串表达式，第二个参数是一个函数。这个函数会将第一个参数解析成一个新的字符串，并将其与第二个参数比较，如果两个字符串相等，则返回 true，否则返回 false。
3. 使用 jQuery 内置的 "SUBRULE" 函数，它接收两个参数，第一个参数是一个字符串表达式，第二个参数是一个回调函数。这个回调函数将会被用来生成一个新的字符串，它由第一个参数的字符串和第二个参数的回调函数组成。

最终，这个 "SEP" 函数返回了一个新的函数表达式，使用了上述的规则，并且使用了 jQuery 库中定义的一些函数和规则。


```
//           SEP: ArgS, DEF: () => {
//             $.SUBRULE($.arg);
//           }
//         });
//       });
//
//       $.RULE("arg", () => {
//         $.CONSUME(StringLiteral);
//         $.CONSUME(Equal);
//         $.SUBRULE($.argv);
//       });
//
//       $.RULE("argv", () => {
//         $.OR([
//           {
```js

这段代码使用了JavaScript的函数式编程技巧，定义了一个名为`ALT`的函数，它的作用域内没有任何副作用（side effect），并且返回的一个只读的函数，不会修改外部变量。

具体来说，这段代码定义了一个`ALT`函数，它接受一个参数`StringLiteral`，内部使用了一个只读的函数`CONSUME`来判断参数是否为真，如果是，则返回一个只读的函数，否则返回一个函数，这个只读的函数内部没有任何操作。然后，这个`ALT`函数被定义到了一个名为`this.CONSUME`的对象上，这个对象可能是来自外部模块或者全局变量，它们具有类似于`Object.defineProperty`的功能，可以用来创建一个受保护的`CONSUME`函数，不会被修改。

接下来，又定义了一个名为`ALT`的函数，它的作用域内没有任何副作用，并且返回的一个只读的函数，同样使用了一个只读的函数`CONSUME`来判断参数是否为真，如果是，则返回一个只读的函数，否则返回一个函数，这个只读的函数内部没有任何操作。然后，这个`ALT`函数被定义到了一个名为`this.CONSUME`的对象上，这个对象可能是来自外部模块或者全局变量，它们具有类似于`Object.defineProperty`的功能，可以用来创建一个受保护的`CONSUME`函数，不会被修改。

最后，在`this.CONSUME`对象上，还定义了一个名为`ALT`的函数，它的作用域内没有任何副作用，并且返回的一个只读的函数，同样使用了一个只读的函数`CONSUME`来判断参数是否为真，如果是，则返回一个只读的函数，否则返回一个函数，这个只读的函数内部没有任何操作。这个`ALT`函数的内部可能有一些副作用，但是这些副作用不会被函数本身或者外部变量所影响。


```
//             ALT: () => {
//               this.CONSUME(StringLiteral);
//             }
//           },
//           {
//             ALT: () => {
//               this.CONSUME(NumberLiteral);
//             }
//           },
//           {
//             ALT: () => {
//               this.CONSUME(True);
//             }
//           },
//           {
```js

这段代码是一个 TypeScript 函数，它的作用是执行 ALT 语法的自检查。ALT 算法是一种 那么就必须慎重考虑 算法，用于检测程序中的逻辑错误。这个函数的作用是确保在函数内部的所有规则都已经正确设置，以便 TypeScript 不会在编译时产生错误。

函数体内部首先定义了一个 ALT 函数，它的返回值为 `true`。然后，定义了一个箭头函数，它的作用是调用 ALT 函数，并将结果存储回函数本身。这个箭头函数包含一个空括号，表明里面可能会有一个函数体，但实际上它不会执行任何操作。

最后，定义了一个函数，它的作用是调用 `performSelfAnalysis` 函数，以确保所有规则都已经正确设置。这个函数在调用 `performSelfAnalysis` 之后，可能会执行一些自检查操作，以确保函数内部的所有规则都正确，从而使 TypeScript 不会在编译时产生错误。


```
//             ALT: () => {
//               this.CONSUME(False);
//             }
//           }]);
//       });
//
//       // very important to call this after all the rules have been setup.
//       // otherwise the parser may not work correctly as it will lack information
//       // derived from the self analysis.
//       this.performSelfAnalysis();
//     }
//
//   }
//
//
```js

这段代码定义了一个返回对象，其中包含两个字段：`lexer` 和 `parser`。`lexer` 字段是一个 WebGalLexer 对象，这是一个 WebGL工具类，用于定义在 Playwright 中使用的原生客户端解析器。`parser` 字段是一个 webgalScriptParser 对象，它允许使用 Playwright 的原生的 ESScript API。

另外，还有一个字段 `defaultRule`，它的值为 "scene"。这个字段用于在解析器无法解析场景或者定义规则时进行默认的规则处理，例如，场景定义中的 `浏览器` 字段如果没有被显式地定义，那么 `defaultRule` 就会生效。

最后，通过 `export const parser4 = 'unreleased'` 将这个返回对象暴露出去，以便其他地方使用。


```
//   // for the playground to work the returned object must contain these fields
//   return {
//     lexer: WebGalLexer,
//     parser: webgalScriptParser,
//     defaultRule: "scene"
//   };
// }());
export const parser4 = 'unreleased'

```